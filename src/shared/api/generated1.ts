/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
 * –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è API
 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from './custom-instance';
import type { ErrorType , BodyType } from './custom-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

export interface Course {
  readonly id?: number;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title_ru: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title_kz: string;
  /** @minLength 1 */
  description_ru: string;
  /** @minLength 1 */
  description_kz: string;
  price: string;
  is_published?: boolean;
}

export type FinalTestQuestionsRu = { [key: string]: unknown };

export type FinalTestQuestionsKz = { [key: string]: unknown };

export type FinalTestAnswerRu = { [key: string]: unknown };

export type FinalTestAnswerKz = { [key: string]: unknown };

export interface FinalTest {
  readonly id?: number;
  questions_ru: FinalTestQuestionsRu;
  questions_kz: FinalTestQuestionsKz;
  answer_ru: FinalTestAnswerRu;
  answer_kz: FinalTestAnswerKz;
  readonly created_at?: string;
  course: number;
}

export type LessonTestQuestionsRu = { [key: string]: unknown };

export type LessonTestQuestionsKz = { [key: string]: unknown };

export type LessonTestAnswerRu = { [key: string]: unknown };

export type LessonTestAnswerKz = { [key: string]: unknown };

export interface LessonTest {
  readonly id?: number;
  questions_ru: LessonTestQuestionsRu;
  questions_kz: LessonTestQuestionsKz;
  answer_ru: LessonTestAnswerRu;
  answer_kz: LessonTestAnswerKz;
  readonly created_at?: string;
  lesson: number;
}

export interface Lesson {
  readonly id?: number;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title_ru: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title_kz: string;
  /** @minLength 1 */
  content_ru: string;
  /** @minLength 1 */
  content_kz: string;
  /** @nullable */
  readonly media_ru?: string | null;
  /** @nullable */
  readonly media_kz?: string | null;
  /**
   * @minimum 0
   * @maximum 9223372036854776000
   */
  order_num: number;
  course: number;
}

export interface Payment {
  readonly id?: number;
  amount: string;
  /**
   * @minLength 1
   * @maxLength 10
   */
  status?: string;
  readonly created_at?: string;
  user: number;
  course: number;
}

export interface TokenRefresh {
  /** @minLength 1 */
  refresh: string;
  /** @minLength 1 */
  readonly access?: string;
}

export type UserRole = typeof UserRole[keyof typeof UserRole];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserRole = {
  student: 'student',
  teacher: 'teacher',
  admin: 'admin',
} as const;

export interface User {
  readonly id?: number;
  /**
   * @minLength 1
   * @maxLength 15
   */
  phone_number: string;
  /**
   * @maxLength 255
   * @nullable
   */
  full_name?: string | null;
  role?: UserRole;
  /**
   * @minLength 1
   * @maxLength 22
   */
  iin: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  position: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  workplace: string;
}

export type FinalTestBody = FinalTest;

export type LessonBody = Lesson;

export type CourseBody = Course;

export type LessonTestBody = LessonTest;

export type PaymentBody = Payment;

export type AvailableCoursesList200Item = {
  /** ID –∫—É—Ä—Å–∞ */
  id?: number;
  /** –ù–∞–∑–≤–∞–Ω–∏–µ –∫—É—Ä—Å–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º */
  title_ru?: string;
  /** –ù–∞–∑–≤–∞–Ω–∏–µ –∫—É—Ä—Å–∞ –Ω–∞ –∫–∞–∑–∞—Ö—Å–∫–æ–º */
  title_kz?: string;
  /** –û–ø–∏—Å–∞–Ω–∏–µ –∫—É—Ä—Å–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º */
  description_ru?: string;
  /** –û–ø–∏—Å–∞–Ω–∏–µ –∫—É—Ä—Å–∞ –Ω–∞ –∫–∞–∑–∞—Ö—Å–∫–æ–º */
  description_kz?: string;
  /** –¶–µ–Ω–∞ –∫—É—Ä—Å–∞ */
  price?: number;
  /** –û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω –ª–∏ –∫—É—Ä—Å */
  is_published?: boolean;
};

/**
 * –û—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –≥–¥–µ –∫–ª—é—á ‚Äî –Ω–æ–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞, –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî –≤—ã–±—Ä–∞–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
 */
export type CheckFinalTestCreateBodyAnswers = {[key: string]: string};

/**
 * –Ø–∑—ã–∫ —Ç–µ—Å—Ç–∞
 */
export type CheckFinalTestCreateBodyLanguage = typeof CheckFinalTestCreateBodyLanguage[keyof typeof CheckFinalTestCreateBodyLanguage];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckFinalTestCreateBodyLanguage = {
  ru: 'ru',
  kz: 'kz',
} as const;

export type CheckFinalTestCreateBody = {
  /** ID –∫—É—Ä—Å–∞ */
  course_id: number;
  /** –û—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –≥–¥–µ –∫–ª—é—á ‚Äî –Ω–æ–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞, –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî –≤—ã–±—Ä–∞–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç */
  answers: CheckFinalTestCreateBodyAnswers;
  /** –Ø–∑—ã–∫ —Ç–µ—Å—Ç–∞ */
  language: CheckFinalTestCreateBodyLanguage;
};

export type CheckFinalTestCreate200 = {
  /** –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ */
  correct?: number;
  /** –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤ */
  total?: number;
};

/**
 * –û—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –≥–¥–µ –∫–ª—é—á ‚Äî –Ω–æ–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞, –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî –≤—ã–±—Ä–∞–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç
 */
export type CheckTestCreateBodyAnswers = {[key: string]: string};

/**
 * –Ø–∑—ã–∫ —Ç–µ—Å—Ç–∞
 */
export type CheckTestCreateBodyLanguage = typeof CheckTestCreateBodyLanguage[keyof typeof CheckTestCreateBodyLanguage];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CheckTestCreateBodyLanguage = {
  ru: 'ru',
  kz: 'kz',
} as const;

export type CheckTestCreateBody = {
  /** ID —Ç–µ—Å—Ç–∞ —É—Ä–æ–∫–∞ */
  lesson_id: number;
  /** –û—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –≥–¥–µ –∫–ª—é—á ‚Äî –Ω–æ–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞, –∑–Ω–∞—á–µ–Ω–∏–µ ‚Äî –≤—ã–±—Ä–∞–Ω–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç */
  answers: CheckTestCreateBodyAnswers;
  /** –Ø–∑—ã–∫ —Ç–µ—Å—Ç–∞ */
  language: CheckTestCreateBodyLanguage;
};

export type CheckTestCreate200 = {
  /** –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ */
  correct?: number;
  /** –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–æ–ø—Ä–æ—Å–æ–≤ */
  total?: number;
};

export type CourseLessonsListParams = {
/**
 * ID –∫—É—Ä—Å–∞, –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —É—Ä–æ–∫–∏
 */
course_id: number;
};

export type CourseLessonsList200Item = {
  /** ID —É—Ä–æ–∫–∞ */
  id?: number;
  /** –ù–∞–∑–≤–∞–Ω–∏–µ —É—Ä–æ–∫–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º */
  title_ru?: string;
  /** –ù–∞–∑–≤–∞–Ω–∏–µ —É—Ä–æ–∫–∞ –Ω–∞ –∫–∞–∑–∞—Ö—Å–∫–æ–º */
  title_kz?: string;
  /** –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ —É—Ä–æ–∫–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º */
  content_ru?: string;
  /** –°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ —É—Ä–æ–∫–∞ –Ω–∞ –∫–∞–∑–∞—Ö—Å–∫–æ–º */
  content_kz?: string;
  /** –°—Å—ã–ª–∫–∞ –Ω–∞ –º–µ–¥–∏–∞—Ñ–∞–π–ª –Ω–∞ —Ä—É—Å—Å–∫–æ–º */
  media_ru?: string;
  /** –°—Å—ã–ª–∫–∞ –Ω–∞ –º–µ–¥–∏–∞—Ñ–∞–π–ª –Ω–∞ –∫–∞–∑–∞—Ö—Å–∫–æ–º */
  media_kz?: string;
  /** –ü–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä —É—Ä–æ–∫–∞ */
  order_num?: number;
};

/**
 * –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞, –≥–¥–µ –∫–ª—é—á - ID –≤–æ–ø—Ä–æ—Å–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç
 */
export type FinalTestSubmitCreateBodyAnswers = { [key: string]: unknown };

export type FinalTestSubmitCreateBody = {
  /** Course id */
  course_id?: number;
  /** –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞, –≥–¥–µ –∫–ª—é—á - ID –≤–æ–ø—Ä–æ—Å–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç */
  answers: FinalTestSubmitCreateBodyAnswers;
  /** –Ø–∑—ã–∫, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –≤–æ–ø—Ä–æ—Å—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 'ru') */
  language?: string;
};

export type FinalTestSubmitCreate200 = {
  /** –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ */
  score?: number;
  /** –§–ª–∞–≥, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π, –±—ã–ª –ª–∏ –≤—ã–¥–∞–Ω —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç */
  certificate_issued?: boolean;
};

export type GeneratePresignedUrlCreateBody = {
  /** –ò–º—è —Ñ–∞–π–ª–∞, –≤–∫–ª—é—á–∞—è —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä, video.mp4) */
  file_name: string;
  /** MIME-—Ç–∏–ø —Ñ–∞–π–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, video/mp4) */
  content_type?: string;
};

/**
 * –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã, –≥–¥–µ –∫–ª—é—á - ID –≤–æ–ø—Ä–æ—Å–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç
 */
export type LessonTestSubmitCreateBodyAnswers = { [key: string]: unknown };

export type LessonTestSubmitCreateBody = {
  /** Lesson test id */
  lesson_test_id?: number;
  /** –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã, –≥–¥–µ –∫–ª—é—á - ID –≤–æ–ø—Ä–æ—Å–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç */
  answers: LessonTestSubmitCreateBodyAnswers;
  /** –Ø–∑—ã–∫, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –≤–æ–ø—Ä–æ—Å—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 'ru') */
  language?: string;
};

export type LessonTestSubmitCreate200 = {
  /** –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ */
  score?: number;
};

export type LessonPartialUpdateBody = {
  /** –ù–∞–∑–≤–∞–Ω–∏–µ –Ω–∞ —Ä—É—Å—Å–∫–æ–º */
  title_ru?: string;
  /** –ù–∞–∑–≤–∞–Ω–∏–µ –Ω–∞ –∫–∞–∑–∞—Ö—Å–∫–æ–º */
  title_kz?: string;
  /** –ö–æ–Ω—Ç–µ–Ω—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º */
  content_ru?: string;
  /** –ö–æ–Ω—Ç–µ–Ω—Ç –Ω–∞ –∫–∞–∑–∞—Ö—Å–∫–æ–º */
  content_kz?: string;
  /** –ù–æ–º–µ—Ä –ø–æ—Ä—è–¥–∫–∞ */
  order_num?: number;
  /** –í–∏–¥–µ–æ –Ω–∞ —Ä—É—Å—Å–∫–æ–º */
  media_ru?: string;
  /** –í–∏–¥–µ–æ –Ω–∞ –∫–∞–∑–∞—Ö—Å–∫–æ–º */
  media_kz?: string;
};

export type LoginCreateBody = {
  /** –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
  phone_number: string;
  /** –ü–∞—Ä–æ–ª—å */
  password: string;
};

export type LoginCreate200 = {
  /** Access-—Ç–æ–∫–µ–Ω */
  access?: string;
  /** Refresh-—Ç–æ–∫–µ–Ω */
  refresh?: string;
  /** –ü–æ–ª–Ω–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  full_name?: string;
  /** –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
  phone_number?: string;
};

export type PurchaseCourseCreateBody = {
  /** ID –∫—É—Ä—Å–∞ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ */
  course_id: number;
};

export type PurchaseCourseCreate201 = {
  /** –°–æ–æ–±—â–µ–Ω–∏–µ –æ —Å—Ç–∞—Ç—É—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ */
  message?: string;
  /** ID —Å–æ–∑–¥–∞–Ω–Ω–æ–π –æ–ø–ª–∞—Ç—ã */
  payment_id?: number;
};

export type SendCodeCreateBody = {
  /** –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
  phone_number: string;
};

export type UserCertificatesList200Item = {
  /** ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  user?: number;
  /** ID –∫—É—Ä—Å–∞ */
  course?: number;
  /** –î–∞—Ç–∞ –≤—ã–¥–∞—á–∏ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞ */
  issued_at?: string;
};

export type UserCourseActivateCreateBody = {
  /** ID of the user course */
  user_course_id: number;
};

export type UserCoursesList200Item = {
  /** ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  user?: number;
  /** ID –∫—É—Ä—Å–∞ */
  course?: number;
  /** –ï—Å—Ç—å –ª–∏ –¥–æ—Å—Ç—É–ø */
  has_access?: boolean;
  /** –î–∞—Ç–∞ –∑–∞—á–∏—Å–ª–µ–Ω–∏—è */
  enrolled_at?: string;
};

export type UserListParams = {
/**
 * ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
user_id: number;
};

export type VerifyCodeCreateBody = {
  /** –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
  phone_number: string;
  /** –ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–∑ SMS */
  code: string;
  /** –§–ò–û –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  full_name: string;
  /** –ü–∞—Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  password: string;
  /** –î–æ–ª–∂–Ω–æ—Å—Ç—å */
  position?: string;
  /** –ú–µ—Å—Ç–æ —Ä–∞–±–æ—Ç—ã */
  workplace?: string;
  /** –ò–ò–ù */
  iin?: string;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –∫—É—Ä—Å–æ–≤.
 */
export const availableCoursesList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<AvailableCoursesList200Item[]>(
      {url: `/available-courses/`, method: 'GET', signal
    },
      options);
    }
  

export const getAvailableCoursesListQueryKey = () => {
    return [`/available-courses/`] as const;
    }

    
export const getAvailableCoursesListQueryOptions = <TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAvailableCoursesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof availableCoursesList>>> = ({ signal }) => availableCoursesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AvailableCoursesListQueryResult = NonNullable<Awaited<ReturnType<typeof availableCoursesList>>>
export type AvailableCoursesListQueryError = ErrorType<void>


export function useAvailableCoursesList<TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof availableCoursesList>>,
          TError,
          Awaited<ReturnType<typeof availableCoursesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAvailableCoursesList<TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof availableCoursesList>>,
          TError,
          Awaited<ReturnType<typeof availableCoursesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAvailableCoursesList<TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAvailableCoursesList<TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAvailableCoursesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç
 */
export const checkFinalTestCreate = (
    checkFinalTestCreateBody: BodyType<CheckFinalTestCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CheckFinalTestCreate200>(
      {url: `/check-final-test/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: checkFinalTestCreateBody, signal
    },
      options);
    }
  


export const getCheckFinalTestCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkFinalTestCreate>>, TError,{data: BodyType<CheckFinalTestCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof checkFinalTestCreate>>, TError,{data: BodyType<CheckFinalTestCreateBody>}, TContext> => {
    
const mutationKey = ['checkFinalTestCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkFinalTestCreate>>, {data: BodyType<CheckFinalTestCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  checkFinalTestCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckFinalTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkFinalTestCreate>>>
    export type CheckFinalTestCreateMutationBody = BodyType<CheckFinalTestCreateBody>
    export type CheckFinalTestCreateMutationError = ErrorType<void>

    export const useCheckFinalTestCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkFinalTestCreate>>, TError,{data: BodyType<CheckFinalTestCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkFinalTestCreate>>,
        TError,
        {data: BodyType<CheckFinalTestCreateBody>},
        TContext
      > => {

      const mutationOptions = getCheckFinalTestCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ —Ç–µ—Å—Ç —É—Ä–æ–∫–∞
 */
export const checkTestCreate = (
    checkTestCreateBody: BodyType<CheckTestCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CheckTestCreate200>(
      {url: `/check-test/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: checkTestCreateBody, signal
    },
      options);
    }
  


export const getCheckTestCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkTestCreate>>, TError,{data: BodyType<CheckTestCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof checkTestCreate>>, TError,{data: BodyType<CheckTestCreateBody>}, TContext> => {
    
const mutationKey = ['checkTestCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkTestCreate>>, {data: BodyType<CheckTestCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  checkTestCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CheckTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof checkTestCreate>>>
    export type CheckTestCreateMutationBody = BodyType<CheckTestCreateBody>
    export type CheckTestCreateMutationError = ErrorType<void>

    export const useCheckTestCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkTestCreate>>, TError,{data: BodyType<CheckTestCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkTestCreate>>,
        TError,
        {data: BodyType<CheckTestCreateBody>},
        TContext
      > => {

      const mutationOptions = getCheckTestCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —É—Ä–æ–∫–æ–≤ –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∫—É—Ä—Å–∞.
 */
export const courseLessonsList = (
    params: CourseLessonsListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CourseLessonsList200Item[]>(
      {url: `/course-lessons/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getCourseLessonsListQueryKey = (params: CourseLessonsListParams,) => {
    return [`/course-lessons/`, ...(params ? [params]: [])] as const;
    }

    
export const getCourseLessonsListQueryOptions = <TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = ErrorType<void>>(params: CourseLessonsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCourseLessonsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof courseLessonsList>>> = ({ signal }) => courseLessonsList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CourseLessonsListQueryResult = NonNullable<Awaited<ReturnType<typeof courseLessonsList>>>
export type CourseLessonsListQueryError = ErrorType<void>


export function useCourseLessonsList<TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = ErrorType<void>>(
 params: CourseLessonsListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseLessonsList>>,
          TError,
          Awaited<ReturnType<typeof courseLessonsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseLessonsList<TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = ErrorType<void>>(
 params: CourseLessonsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseLessonsList>>,
          TError,
          Awaited<ReturnType<typeof courseLessonsList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseLessonsList<TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = ErrorType<void>>(
 params: CourseLessonsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCourseLessonsList<TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = ErrorType<void>>(
 params: CourseLessonsListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCourseLessonsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –∫—É—Ä—Å–æ–≤
 */
export const courseList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Course[]>(
      {url: `/course/`, method: 'GET', signal
    },
      options);
    }
  

export const getCourseListQueryKey = () => {
    return [`/course/`] as const;
    }

    
export const getCourseListQueryOptions = <TData = Awaited<ReturnType<typeof courseList>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCourseListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof courseList>>> = ({ signal }) => courseList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CourseListQueryResult = NonNullable<Awaited<ReturnType<typeof courseList>>>
export type CourseListQueryError = ErrorType<void>


export function useCourseList<TData = Awaited<ReturnType<typeof courseList>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseList>>,
          TError,
          Awaited<ReturnType<typeof courseList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseList<TData = Awaited<ReturnType<typeof courseList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseList>>,
          TError,
          Awaited<ReturnType<typeof courseList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseList<TData = Awaited<ReturnType<typeof courseList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCourseList<TData = Awaited<ReturnType<typeof courseList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCourseListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∫—É—Ä—Å–∞
 */
export const courseCreate = (
    courseBody: BodyType<CourseBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Course>(
      {url: `/course/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: courseBody, signal
    },
      options);
    }
  


export const getCourseCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseCreate>>, TError,{data: BodyType<CourseBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof courseCreate>>, TError,{data: BodyType<CourseBody>}, TContext> => {
    
const mutationKey = ['courseCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof courseCreate>>, {data: BodyType<CourseBody>}> = (props) => {
          const {data} = props ?? {};

          return  courseCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CourseCreateMutationResult = NonNullable<Awaited<ReturnType<typeof courseCreate>>>
    export type CourseCreateMutationBody = BodyType<CourseBody>
    export type CourseCreateMutationError = ErrorType<void>

    export const useCourseCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseCreate>>, TError,{data: BodyType<CourseBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof courseCreate>>,
        TError,
        {data: BodyType<CourseBody>},
        TContext
      > => {

      const mutationOptions = getCourseCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫—É—Ä—Å–µ –ø–æ ID
 */
export const courseRead = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Course>(
      {url: `/course/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getCourseReadQueryKey = (id: number,) => {
    return [`/course/${id}/`] as const;
    }

    
export const getCourseReadQueryOptions = <TData = Awaited<ReturnType<typeof courseRead>>, TError = ErrorType<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCourseReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof courseRead>>> = ({ signal }) => courseRead(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CourseReadQueryResult = NonNullable<Awaited<ReturnType<typeof courseRead>>>
export type CourseReadQueryError = ErrorType<void>


export function useCourseRead<TData = Awaited<ReturnType<typeof courseRead>>, TError = ErrorType<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseRead>>,
          TError,
          Awaited<ReturnType<typeof courseRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseRead<TData = Awaited<ReturnType<typeof courseRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseRead>>,
          TError,
          Awaited<ReturnType<typeof courseRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseRead<TData = Awaited<ReturnType<typeof courseRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCourseRead<TData = Awaited<ReturnType<typeof courseRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCourseReadQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫—É—Ä—Å–µ
 */
export const courseUpdate = (
    id: number,
    courseBody: BodyType<CourseBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Course>(
      {url: `/course/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: courseBody
    },
      options);
    }
  


export const getCourseUpdateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseUpdate>>, TError,{id: number;data: BodyType<CourseBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof courseUpdate>>, TError,{id: number;data: BodyType<CourseBody>}, TContext> => {
    
const mutationKey = ['courseUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof courseUpdate>>, {id: number;data: BodyType<CourseBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  courseUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CourseUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof courseUpdate>>>
    export type CourseUpdateMutationBody = BodyType<CourseBody>
    export type CourseUpdateMutationError = ErrorType<void>

    export const useCourseUpdate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseUpdate>>, TError,{id: number;data: BodyType<CourseBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof courseUpdate>>,
        TError,
        {id: number;data: BodyType<CourseBody>},
        TContext
      > => {

      const mutationOptions = getCourseUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const coursePartialUpdate = (
    id: number,
    courseBody: BodyType<CourseBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Course>(
      {url: `/course/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: courseBody
    },
      options);
    }
  


export const getCoursePartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coursePartialUpdate>>, TError,{id: number;data: BodyType<CourseBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof coursePartialUpdate>>, TError,{id: number;data: BodyType<CourseBody>}, TContext> => {
    
const mutationKey = ['coursePartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coursePartialUpdate>>, {id: number;data: BodyType<CourseBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  coursePartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoursePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coursePartialUpdate>>>
    export type CoursePartialUpdateMutationBody = BodyType<CourseBody>
    export type CoursePartialUpdateMutationError = ErrorType<unknown>

    export const useCoursePartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coursePartialUpdate>>, TError,{id: number;data: BodyType<CourseBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof coursePartialUpdate>>,
        TError,
        {id: number;data: BodyType<CourseBody>},
        TContext
      > => {

      const mutationOptions = getCoursePartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ –∫—É—Ä—Å–∞ –ø–æ ID
 */
export const courseDelete = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/course/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getCourseDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof courseDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['courseDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof courseDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  courseDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CourseDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof courseDelete>>>
    
    export type CourseDeleteMutationError = ErrorType<void>

    export const useCourseDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof courseDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCourseDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç –∫—É—Ä—Å–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏ —Å –≤–æ–∑–º–æ–∂–Ω—ã–º –≤—ã–¥–∞—á–µ–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞
 */
export const finalTestSubmitCreate = (
    finalTestSubmitCreateBody: BodyType<FinalTestSubmitCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FinalTestSubmitCreate200>(
      {url: `/final-test-submit/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: finalTestSubmitCreateBody, signal
    },
      options);
    }
  


export const getFinalTestSubmitCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestSubmitCreate>>, TError,{data: BodyType<FinalTestSubmitCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestSubmitCreate>>, TError,{data: BodyType<FinalTestSubmitCreateBody>}, TContext> => {
    
const mutationKey = ['finalTestSubmitCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestSubmitCreate>>, {data: BodyType<FinalTestSubmitCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  finalTestSubmitCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestSubmitCreateMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestSubmitCreate>>>
    export type FinalTestSubmitCreateMutationBody = BodyType<FinalTestSubmitCreateBody>
    export type FinalTestSubmitCreateMutationError = ErrorType<void>

    export const useFinalTestSubmitCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestSubmitCreate>>, TError,{data: BodyType<FinalTestSubmitCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalTestSubmitCreate>>,
        TError,
        {data: BodyType<FinalTestSubmitCreateBody>},
        TContext
      > => {

      const mutationOptions = getFinalTestSubmitCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤
 */
export const finalTestList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FinalTest[]>(
      {url: `/final-test/`, method: 'GET', signal
    },
      options);
    }
  

export const getFinalTestListQueryKey = () => {
    return [`/final-test/`] as const;
    }

    
export const getFinalTestListQueryOptions = <TData = Awaited<ReturnType<typeof finalTestList>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFinalTestListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof finalTestList>>> = ({ signal }) => finalTestList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FinalTestListQueryResult = NonNullable<Awaited<ReturnType<typeof finalTestList>>>
export type FinalTestListQueryError = ErrorType<void>


export function useFinalTestList<TData = Awaited<ReturnType<typeof finalTestList>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof finalTestList>>,
          TError,
          Awaited<ReturnType<typeof finalTestList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFinalTestList<TData = Awaited<ReturnType<typeof finalTestList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof finalTestList>>,
          TError,
          Awaited<ReturnType<typeof finalTestList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFinalTestList<TData = Awaited<ReturnType<typeof finalTestList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFinalTestList<TData = Awaited<ReturnType<typeof finalTestList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFinalTestListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞
 */
export const finalTestCreate = (
    finalTestBody: BodyType<FinalTestBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FinalTest>(
      {url: `/final-test/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: finalTestBody, signal
    },
      options);
    }
  


export const getFinalTestCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestCreate>>, TError,{data: BodyType<FinalTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestCreate>>, TError,{data: BodyType<FinalTestBody>}, TContext> => {
    
const mutationKey = ['finalTestCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestCreate>>, {data: BodyType<FinalTestBody>}> = (props) => {
          const {data} = props ?? {};

          return  finalTestCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestCreate>>>
    export type FinalTestCreateMutationBody = BodyType<FinalTestBody>
    export type FinalTestCreateMutationError = ErrorType<void>

    export const useFinalTestCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestCreate>>, TError,{data: BodyType<FinalTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalTestCreate>>,
        TError,
        {data: BodyType<FinalTestBody>},
        TContext
      > => {

      const mutationOptions = getFinalTestCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º —Ç–µ—Å—Ç–µ –ø–æ ID
 */
export const finalTestRead = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FinalTest>(
      {url: `/final-test/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getFinalTestReadQueryKey = (id: number,) => {
    return [`/final-test/${id}/`] as const;
    }

    
export const getFinalTestReadQueryOptions = <TData = Awaited<ReturnType<typeof finalTestRead>>, TError = ErrorType<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFinalTestReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof finalTestRead>>> = ({ signal }) => finalTestRead(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FinalTestReadQueryResult = NonNullable<Awaited<ReturnType<typeof finalTestRead>>>
export type FinalTestReadQueryError = ErrorType<void>


export function useFinalTestRead<TData = Awaited<ReturnType<typeof finalTestRead>>, TError = ErrorType<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof finalTestRead>>,
          TError,
          Awaited<ReturnType<typeof finalTestRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFinalTestRead<TData = Awaited<ReturnType<typeof finalTestRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof finalTestRead>>,
          TError,
          Awaited<ReturnType<typeof finalTestRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFinalTestRead<TData = Awaited<ReturnType<typeof finalTestRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFinalTestRead<TData = Awaited<ReturnType<typeof finalTestRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFinalTestReadQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞
 */
export const finalTestUpdate = (
    id: number,
    finalTestBody: BodyType<FinalTestBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<FinalTest>(
      {url: `/final-test/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: finalTestBody
    },
      options);
    }
  


export const getFinalTestUpdateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestUpdate>>, TError,{id: number;data: BodyType<FinalTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestUpdate>>, TError,{id: number;data: BodyType<FinalTestBody>}, TContext> => {
    
const mutationKey = ['finalTestUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestUpdate>>, {id: number;data: BodyType<FinalTestBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  finalTestUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestUpdate>>>
    export type FinalTestUpdateMutationBody = BodyType<FinalTestBody>
    export type FinalTestUpdateMutationError = ErrorType<void>

    export const useFinalTestUpdate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestUpdate>>, TError,{id: number;data: BodyType<FinalTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalTestUpdate>>,
        TError,
        {id: number;data: BodyType<FinalTestBody>},
        TContext
      > => {

      const mutationOptions = getFinalTestUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const finalTestPartialUpdate = (
    id: number,
    finalTestBody: BodyType<FinalTestBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<FinalTest>(
      {url: `/final-test/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: finalTestBody
    },
      options);
    }
  


export const getFinalTestPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestPartialUpdate>>, TError,{id: number;data: BodyType<FinalTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestPartialUpdate>>, TError,{id: number;data: BodyType<FinalTestBody>}, TContext> => {
    
const mutationKey = ['finalTestPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestPartialUpdate>>, {id: number;data: BodyType<FinalTestBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  finalTestPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestPartialUpdate>>>
    export type FinalTestPartialUpdateMutationBody = BodyType<FinalTestBody>
    export type FinalTestPartialUpdateMutationError = ErrorType<unknown>

    export const useFinalTestPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestPartialUpdate>>, TError,{id: number;data: BodyType<FinalTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalTestPartialUpdate>>,
        TError,
        {id: number;data: BodyType<FinalTestBody>},
        TContext
      > => {

      const mutationOptions = getFinalTestPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞ –ø–æ ID
 */
export const finalTestDelete = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/final-test/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getFinalTestDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['finalTestDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  finalTestDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestDelete>>>
    
    export type FinalTestDeleteMutationError = ErrorType<void>

    export const useFinalTestDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof finalTestDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getFinalTestDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è presigned URL –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –º–µ–¥–∏–∞—Ñ–∞–π–ª–∞ –≤ Cloudflare R2.
 */
export const generatePresignedUrlCreate = (
    generatePresignedUrlCreateBody: BodyType<GeneratePresignedUrlCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/generate-presigned-url/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: generatePresignedUrlCreateBody, signal
    },
      options);
    }
  


export const getGeneratePresignedUrlCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePresignedUrlCreate>>, TError,{data: BodyType<GeneratePresignedUrlCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof generatePresignedUrlCreate>>, TError,{data: BodyType<GeneratePresignedUrlCreateBody>}, TContext> => {
    
const mutationKey = ['generatePresignedUrlCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generatePresignedUrlCreate>>, {data: BodyType<GeneratePresignedUrlCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  generatePresignedUrlCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GeneratePresignedUrlCreateMutationResult = NonNullable<Awaited<ReturnType<typeof generatePresignedUrlCreate>>>
    export type GeneratePresignedUrlCreateMutationBody = BodyType<GeneratePresignedUrlCreateBody>
    export type GeneratePresignedUrlCreateMutationError = ErrorType<void>

    export const useGeneratePresignedUrlCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generatePresignedUrlCreate>>, TError,{data: BodyType<GeneratePresignedUrlCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof generatePresignedUrlCreate>>,
        TError,
        {data: BodyType<GeneratePresignedUrlCreateBody>},
        TContext
      > => {

      const mutationOptions = getGeneratePresignedUrlCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ —Ç–µ—Å—Ç —É—Ä–æ–∫–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏
 */
export const lessonTestSubmitCreate = (
    lessonTestSubmitCreateBody: BodyType<LessonTestSubmitCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LessonTestSubmitCreate200>(
      {url: `/lesson-test-submit/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: lessonTestSubmitCreateBody, signal
    },
      options);
    }
  


export const getLessonTestSubmitCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestSubmitCreate>>, TError,{data: BodyType<LessonTestSubmitCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestSubmitCreate>>, TError,{data: BodyType<LessonTestSubmitCreateBody>}, TContext> => {
    
const mutationKey = ['lessonTestSubmitCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestSubmitCreate>>, {data: BodyType<LessonTestSubmitCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  lessonTestSubmitCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestSubmitCreateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestSubmitCreate>>>
    export type LessonTestSubmitCreateMutationBody = BodyType<LessonTestSubmitCreateBody>
    export type LessonTestSubmitCreateMutationError = ErrorType<void>

    export const useLessonTestSubmitCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestSubmitCreate>>, TError,{data: BodyType<LessonTestSubmitCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestSubmitCreate>>,
        TError,
        {data: BodyType<LessonTestSubmitCreateBody>},
        TContext
      > => {

      const mutationOptions = getLessonTestSubmitCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ –∫ —É—Ä–æ–∫–∞–º
 */
export const lessonTestList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LessonTest[]>(
      {url: `/lesson-test/`, method: 'GET', signal
    },
      options);
    }
  

export const getLessonTestListQueryKey = () => {
    return [`/lesson-test/`] as const;
    }

    
export const getLessonTestListQueryOptions = <TData = Awaited<ReturnType<typeof lessonTestList>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLessonTestListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lessonTestList>>> = ({ signal }) => lessonTestList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LessonTestListQueryResult = NonNullable<Awaited<ReturnType<typeof lessonTestList>>>
export type LessonTestListQueryError = ErrorType<void>


export function useLessonTestList<TData = Awaited<ReturnType<typeof lessonTestList>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonTestList>>,
          TError,
          Awaited<ReturnType<typeof lessonTestList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonTestList<TData = Awaited<ReturnType<typeof lessonTestList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonTestList>>,
          TError,
          Awaited<ReturnType<typeof lessonTestList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonTestList<TData = Awaited<ReturnType<typeof lessonTestList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLessonTestList<TData = Awaited<ReturnType<typeof lessonTestList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLessonTestListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç–µ—Å—Ç–∞
 */
export const lessonTestCreate = (
    lessonTestBody: BodyType<LessonTestBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LessonTest>(
      {url: `/lesson-test/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: lessonTestBody, signal
    },
      options);
    }
  


export const getLessonTestCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestCreate>>, TError,{data: BodyType<LessonTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestCreate>>, TError,{data: BodyType<LessonTestBody>}, TContext> => {
    
const mutationKey = ['lessonTestCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestCreate>>, {data: BodyType<LessonTestBody>}> = (props) => {
          const {data} = props ?? {};

          return  lessonTestCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestCreate>>>
    export type LessonTestCreateMutationBody = BodyType<LessonTestBody>
    export type LessonTestCreateMutationError = ErrorType<void>

    export const useLessonTestCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestCreate>>, TError,{data: BodyType<LessonTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestCreate>>,
        TError,
        {data: BodyType<LessonTestBody>},
        TContext
      > => {

      const mutationOptions = getLessonTestCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ—Å—Ç–µ –ø–æ ID
 */
export const lessonTestRead = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LessonTest>(
      {url: `/lesson-test/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getLessonTestReadQueryKey = (id: number,) => {
    return [`/lesson-test/${id}/`] as const;
    }

    
export const getLessonTestReadQueryOptions = <TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = ErrorType<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLessonTestReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lessonTestRead>>> = ({ signal }) => lessonTestRead(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LessonTestReadQueryResult = NonNullable<Awaited<ReturnType<typeof lessonTestRead>>>
export type LessonTestReadQueryError = ErrorType<void>


export function useLessonTestRead<TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = ErrorType<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonTestRead>>,
          TError,
          Awaited<ReturnType<typeof lessonTestRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonTestRead<TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonTestRead>>,
          TError,
          Awaited<ReturnType<typeof lessonTestRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonTestRead<TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLessonTestRead<TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLessonTestReadQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–∞
 */
export const lessonTestUpdate = (
    id: number,
    lessonTestBody: BodyType<LessonTestBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<LessonTest>(
      {url: `/lesson-test/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: lessonTestBody
    },
      options);
    }
  


export const getLessonTestUpdateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestUpdate>>, TError,{id: number;data: BodyType<LessonTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestUpdate>>, TError,{id: number;data: BodyType<LessonTestBody>}, TContext> => {
    
const mutationKey = ['lessonTestUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestUpdate>>, {id: number;data: BodyType<LessonTestBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  lessonTestUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestUpdate>>>
    export type LessonTestUpdateMutationBody = BodyType<LessonTestBody>
    export type LessonTestUpdateMutationError = ErrorType<void>

    export const useLessonTestUpdate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestUpdate>>, TError,{id: number;data: BodyType<LessonTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestUpdate>>,
        TError,
        {id: number;data: BodyType<LessonTestBody>},
        TContext
      > => {

      const mutationOptions = getLessonTestUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const lessonTestPartialUpdate = (
    id: number,
    lessonTestBody: BodyType<LessonTestBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<LessonTest>(
      {url: `/lesson-test/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: lessonTestBody
    },
      options);
    }
  


export const getLessonTestPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestPartialUpdate>>, TError,{id: number;data: BodyType<LessonTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestPartialUpdate>>, TError,{id: number;data: BodyType<LessonTestBody>}, TContext> => {
    
const mutationKey = ['lessonTestPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestPartialUpdate>>, {id: number;data: BodyType<LessonTestBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  lessonTestPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestPartialUpdate>>>
    export type LessonTestPartialUpdateMutationBody = BodyType<LessonTestBody>
    export type LessonTestPartialUpdateMutationError = ErrorType<unknown>

    export const useLessonTestPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestPartialUpdate>>, TError,{id: number;data: BodyType<LessonTestBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestPartialUpdate>>,
        TError,
        {id: number;data: BodyType<LessonTestBody>},
        TContext
      > => {

      const mutationOptions = getLessonTestPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–∞ –ø–æ ID
 */
export const lessonTestDelete = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/lesson-test/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getLessonTestDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['lessonTestDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  lessonTestDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestDelete>>>
    
    export type LessonTestDeleteMutationError = ErrorType<void>

    export const useLessonTestDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getLessonTestDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —É—Ä–æ–∫–æ–≤
 */
export const lessonList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Lesson[]>(
      {url: `/lesson/`, method: 'GET', signal
    },
      options);
    }
  

export const getLessonListQueryKey = () => {
    return [`/lesson/`] as const;
    }

    
export const getLessonListQueryOptions = <TData = Awaited<ReturnType<typeof lessonList>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLessonListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lessonList>>> = ({ signal }) => lessonList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LessonListQueryResult = NonNullable<Awaited<ReturnType<typeof lessonList>>>
export type LessonListQueryError = ErrorType<void>


export function useLessonList<TData = Awaited<ReturnType<typeof lessonList>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonList>>,
          TError,
          Awaited<ReturnType<typeof lessonList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonList<TData = Awaited<ReturnType<typeof lessonList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonList>>,
          TError,
          Awaited<ReturnType<typeof lessonList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonList<TData = Awaited<ReturnType<typeof lessonList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLessonList<TData = Awaited<ReturnType<typeof lessonList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLessonListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —É—Ä–æ–∫–∞
 */
export const lessonCreate = (
    lessonBody: BodyType<LessonBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/lesson/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: lessonBody, signal
    },
      options);
    }
  


export const getLessonCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonCreate>>, TError,{data: BodyType<LessonBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonCreate>>, TError,{data: BodyType<LessonBody>}, TContext> => {
    
const mutationKey = ['lessonCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonCreate>>, {data: BodyType<LessonBody>}> = (props) => {
          const {data} = props ?? {};

          return  lessonCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonCreateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonCreate>>>
    export type LessonCreateMutationBody = BodyType<LessonBody>
    export type LessonCreateMutationError = ErrorType<void>

    export const useLessonCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonCreate>>, TError,{data: BodyType<LessonBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonCreate>>,
        TError,
        {data: BodyType<LessonBody>},
        TContext
      > => {

      const mutationOptions = getLessonCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —É—Ä–æ–∫–µ –ø–æ ID
 */
export const lessonRead = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Lesson>(
      {url: `/lesson/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getLessonReadQueryKey = (id: number,) => {
    return [`/lesson/${id}/`] as const;
    }

    
export const getLessonReadQueryOptions = <TData = Awaited<ReturnType<typeof lessonRead>>, TError = ErrorType<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLessonReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lessonRead>>> = ({ signal }) => lessonRead(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LessonReadQueryResult = NonNullable<Awaited<ReturnType<typeof lessonRead>>>
export type LessonReadQueryError = ErrorType<void>


export function useLessonRead<TData = Awaited<ReturnType<typeof lessonRead>>, TError = ErrorType<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonRead>>,
          TError,
          Awaited<ReturnType<typeof lessonRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonRead<TData = Awaited<ReturnType<typeof lessonRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonRead>>,
          TError,
          Awaited<ReturnType<typeof lessonRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonRead<TData = Awaited<ReturnType<typeof lessonRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLessonRead<TData = Awaited<ReturnType<typeof lessonRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLessonReadQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —É—Ä–æ–∫–µ
 */
export const lessonUpdate = (
    id: number,
    lessonBody: BodyType<LessonBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Lesson>(
      {url: `/lesson/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: lessonBody
    },
      options);
    }
  


export const getLessonUpdateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonUpdate>>, TError,{id: number;data: BodyType<LessonBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonUpdate>>, TError,{id: number;data: BodyType<LessonBody>}, TContext> => {
    
const mutationKey = ['lessonUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonUpdate>>, {id: number;data: BodyType<LessonBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  lessonUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonUpdate>>>
    export type LessonUpdateMutationBody = BodyType<LessonBody>
    export type LessonUpdateMutationError = ErrorType<void>

    export const useLessonUpdate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonUpdate>>, TError,{id: number;data: BodyType<LessonBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonUpdate>>,
        TError,
        {id: number;data: BodyType<LessonBody>},
        TContext
      > => {

      const mutationOptions = getLessonUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —É—Ä–æ–∫–µ (partial update)
 */
export const lessonPartialUpdate = (
    id: number,
    lessonPartialUpdateBody: BodyType<LessonPartialUpdateBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Lesson>(
      {url: `/lesson/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: lessonPartialUpdateBody
    },
      options);
    }
  


export const getLessonPartialUpdateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonPartialUpdate>>, TError,{id: number;data: BodyType<LessonPartialUpdateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonPartialUpdate>>, TError,{id: number;data: BodyType<LessonPartialUpdateBody>}, TContext> => {
    
const mutationKey = ['lessonPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonPartialUpdate>>, {id: number;data: BodyType<LessonPartialUpdateBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  lessonPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonPartialUpdate>>>
    export type LessonPartialUpdateMutationBody = BodyType<LessonPartialUpdateBody>
    export type LessonPartialUpdateMutationError = ErrorType<void>

    export const useLessonPartialUpdate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonPartialUpdate>>, TError,{id: number;data: BodyType<LessonPartialUpdateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonPartialUpdate>>,
        TError,
        {id: number;data: BodyType<LessonPartialUpdateBody>},
        TContext
      > => {

      const mutationOptions = getLessonPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ —É—Ä–æ–∫–∞ –ø–æ ID
 */
export const lessonDelete = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/lesson/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getLessonDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof lessonDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['lessonDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  lessonDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof lessonDelete>>>
    
    export type LessonDeleteMutationError = ErrorType<void>

    export const useLessonDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof lessonDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getLessonDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ –Ω–æ–º–µ—Ä—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ –ø–∞—Ä–æ–ª—é
 */
export const loginCreate = (
    loginCreateBody: BodyType<LoginCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<LoginCreate200>(
      {url: `/login/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginCreateBody, signal
    },
      options);
    }
  


export const getLoginCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginCreate>>, TError,{data: BodyType<LoginCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginCreate>>, TError,{data: BodyType<LoginCreateBody>}, TContext> => {
    
const mutationKey = ['loginCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginCreate>>, {data: BodyType<LoginCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  loginCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginCreateMutationResult = NonNullable<Awaited<ReturnType<typeof loginCreate>>>
    export type LoginCreateMutationBody = BodyType<LoginCreateBody>
    export type LoginCreateMutationError = ErrorType<void>

    export const useLoginCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginCreate>>, TError,{data: BodyType<LoginCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginCreate>>,
        TError,
        {data: BodyType<LoginCreateBody>},
        TContext
      > => {

      const mutationOptions = getLoginCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –ø–ª–∞—Ç–µ–∂–µ–π
 */
export const paymentList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Payment[]>(
      {url: `/payment/`, method: 'GET', signal
    },
      options);
    }
  

export const getPaymentListQueryKey = () => {
    return [`/payment/`] as const;
    }

    
export const getPaymentListQueryOptions = <TData = Awaited<ReturnType<typeof paymentList>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentList>>> = ({ signal }) => paymentList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentListQueryResult = NonNullable<Awaited<ReturnType<typeof paymentList>>>
export type PaymentListQueryError = ErrorType<void>


export function usePaymentList<TData = Awaited<ReturnType<typeof paymentList>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentList>>,
          TError,
          Awaited<ReturnType<typeof paymentList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentList<TData = Awaited<ReturnType<typeof paymentList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentList>>,
          TError,
          Awaited<ReturnType<typeof paymentList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentList<TData = Awaited<ReturnType<typeof paymentList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePaymentList<TData = Awaited<ReturnType<typeof paymentList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞
 */
export const paymentCreate = (
    paymentBody: BodyType<PaymentBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Payment>(
      {url: `/payment/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: paymentBody, signal
    },
      options);
    }
  


export const getPaymentCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentCreate>>, TError,{data: BodyType<PaymentBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentCreate>>, TError,{data: BodyType<PaymentBody>}, TContext> => {
    
const mutationKey = ['paymentCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentCreate>>, {data: BodyType<PaymentBody>}> = (props) => {
          const {data} = props ?? {};

          return  paymentCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof paymentCreate>>>
    export type PaymentCreateMutationBody = BodyType<PaymentBody>
    export type PaymentCreateMutationError = ErrorType<void>

    export const usePaymentCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentCreate>>, TError,{data: BodyType<PaymentBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentCreate>>,
        TError,
        {data: BodyType<PaymentBody>},
        TContext
      > => {

      const mutationOptions = getPaymentCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–ª–∞—Ç–µ–∂–µ –ø–æ ID
 */
export const paymentRead = (
    id: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Payment>(
      {url: `/payment/${id}/`, method: 'GET', signal
    },
      options);
    }
  

export const getPaymentReadQueryKey = (id: number,) => {
    return [`/payment/${id}/`] as const;
    }

    
export const getPaymentReadQueryOptions = <TData = Awaited<ReturnType<typeof paymentRead>>, TError = ErrorType<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentRead>>> = ({ signal }) => paymentRead(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentReadQueryResult = NonNullable<Awaited<ReturnType<typeof paymentRead>>>
export type PaymentReadQueryError = ErrorType<void>


export function usePaymentRead<TData = Awaited<ReturnType<typeof paymentRead>>, TError = ErrorType<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentRead>>,
          TError,
          Awaited<ReturnType<typeof paymentRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentRead<TData = Awaited<ReturnType<typeof paymentRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentRead>>,
          TError,
          Awaited<ReturnType<typeof paymentRead>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentRead<TData = Awaited<ReturnType<typeof paymentRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePaymentRead<TData = Awaited<ReturnType<typeof paymentRead>>, TError = ErrorType<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentReadQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞
 */
export const paymentUpdate = (
    id: number,
    paymentBody: BodyType<PaymentBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Payment>(
      {url: `/payment/${id}/`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: paymentBody
    },
      options);
    }
  


export const getPaymentUpdateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentUpdate>>, TError,{id: number;data: BodyType<PaymentBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentUpdate>>, TError,{id: number;data: BodyType<PaymentBody>}, TContext> => {
    
const mutationKey = ['paymentUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentUpdate>>, {id: number;data: BodyType<PaymentBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  paymentUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof paymentUpdate>>>
    export type PaymentUpdateMutationBody = BodyType<PaymentBody>
    export type PaymentUpdateMutationError = ErrorType<void>

    export const usePaymentUpdate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentUpdate>>, TError,{id: number;data: BodyType<PaymentBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentUpdate>>,
        TError,
        {id: number;data: BodyType<PaymentBody>},
        TContext
      > => {

      const mutationOptions = getPaymentUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const paymentPartialUpdate = (
    id: number,
    paymentBody: BodyType<PaymentBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Payment>(
      {url: `/payment/${id}/`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: paymentBody
    },
      options);
    }
  


export const getPaymentPartialUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentPartialUpdate>>, TError,{id: number;data: BodyType<PaymentBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentPartialUpdate>>, TError,{id: number;data: BodyType<PaymentBody>}, TContext> => {
    
const mutationKey = ['paymentPartialUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentPartialUpdate>>, {id: number;data: BodyType<PaymentBody>}> = (props) => {
          const {id,data} = props ?? {};

          return  paymentPartialUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof paymentPartialUpdate>>>
    export type PaymentPartialUpdateMutationBody = BodyType<PaymentBody>
    export type PaymentPartialUpdateMutationError = ErrorType<unknown>

    export const usePaymentPartialUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentPartialUpdate>>, TError,{id: number;data: BodyType<PaymentBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentPartialUpdate>>,
        TError,
        {id: number;data: BodyType<PaymentBody>},
        TContext
      > => {

      const mutationOptions = getPaymentPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ –ø–æ ID
 */
export const paymentDelete = (
    id: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/payment/${id}/`, method: 'DELETE'
    },
      options);
    }
  


export const getPaymentDeleteMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['paymentDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  paymentDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentDelete>>>
    
    export type PaymentDeleteMutationError = ErrorType<void>

    export const usePaymentDelete = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentDelete>>, TError,{id: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPaymentDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø–ª–∞—Ç—ã –∑–∞ –∫—É—Ä—Å.
 */
export const purchaseCourseCreate = (
    purchaseCourseCreateBody: BodyType<PurchaseCourseCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<PurchaseCourseCreate201>(
      {url: `/purchase-course/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: purchaseCourseCreateBody, signal
    },
      options);
    }
  


export const getPurchaseCourseCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchaseCourseCreate>>, TError,{data: BodyType<PurchaseCourseCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof purchaseCourseCreate>>, TError,{data: BodyType<PurchaseCourseCreateBody>}, TContext> => {
    
const mutationKey = ['purchaseCourseCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchaseCourseCreate>>, {data: BodyType<PurchaseCourseCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  purchaseCourseCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PurchaseCourseCreateMutationResult = NonNullable<Awaited<ReturnType<typeof purchaseCourseCreate>>>
    export type PurchaseCourseCreateMutationBody = BodyType<PurchaseCourseCreateBody>
    export type PurchaseCourseCreateMutationError = ErrorType<void>

    export const usePurchaseCourseCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchaseCourseCreate>>, TError,{data: BodyType<PurchaseCourseCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof purchaseCourseCreate>>,
        TError,
        {data: BodyType<PurchaseCourseCreateBody>},
        TContext
      > => {

      const mutationOptions = getPurchaseCourseCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–∞ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞
 */
export const sendCodeCreate = (
    sendCodeCreateBody: BodyType<SendCodeCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/send-code/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendCodeCreateBody, signal
    },
      options);
    }
  


export const getSendCodeCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendCodeCreate>>, TError,{data: BodyType<SendCodeCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof sendCodeCreate>>, TError,{data: BodyType<SendCodeCreateBody>}, TContext> => {
    
const mutationKey = ['sendCodeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendCodeCreate>>, {data: BodyType<SendCodeCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  sendCodeCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendCodeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof sendCodeCreate>>>
    export type SendCodeCreateMutationBody = BodyType<SendCodeCreateBody>
    export type SendCodeCreateMutationError = ErrorType<void>

    export const useSendCodeCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendCodeCreate>>, TError,{data: BodyType<SendCodeCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendCodeCreate>>,
        TError,
        {data: BodyType<SendCodeCreateBody>},
        TContext
      > => {

      const mutationOptions = getSendCodeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * Takes a refresh type JSON web token and returns an access type JSON web
token if the refresh token is valid.
 */
export const tokenRefreshCreate = (
    tokenRefresh: BodyType<NonReadonly<TokenRefresh>>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenRefresh>(
      {url: `/token/refresh/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: tokenRefresh, signal
    },
      options);
    }
  


export const getTokenRefreshCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokenRefreshCreate>>, TError,{data: BodyType<NonReadonly<TokenRefresh>>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof tokenRefreshCreate>>, TError,{data: BodyType<NonReadonly<TokenRefresh>>}, TContext> => {
    
const mutationKey = ['tokenRefreshCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tokenRefreshCreate>>, {data: BodyType<NonReadonly<TokenRefresh>>}> = (props) => {
          const {data} = props ?? {};

          return  tokenRefreshCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TokenRefreshCreateMutationResult = NonNullable<Awaited<ReturnType<typeof tokenRefreshCreate>>>
    export type TokenRefreshCreateMutationBody = BodyType<NonReadonly<TokenRefresh>>
    export type TokenRefreshCreateMutationError = ErrorType<unknown>

    export const useTokenRefreshCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tokenRefreshCreate>>, TError,{data: BodyType<NonReadonly<TokenRefresh>>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof tokenRefreshCreate>>,
        TError,
        {data: BodyType<NonReadonly<TokenRefresh>>},
        TContext
      > => {

      const mutationOptions = getTokenRefreshCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
 */
export const userCertificatesList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserCertificatesList200Item[]>(
      {url: `/user-certificates/`, method: 'GET', signal
    },
      options);
    }
  

export const getUserCertificatesListQueryKey = () => {
    return [`/user-certificates/`] as const;
    }

    
export const getUserCertificatesListQueryOptions = <TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserCertificatesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userCertificatesList>>> = ({ signal }) => userCertificatesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserCertificatesListQueryResult = NonNullable<Awaited<ReturnType<typeof userCertificatesList>>>
export type UserCertificatesListQueryError = ErrorType<void>


export function useUserCertificatesList<TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userCertificatesList>>,
          TError,
          Awaited<ReturnType<typeof userCertificatesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserCertificatesList<TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userCertificatesList>>,
          TError,
          Awaited<ReturnType<typeof userCertificatesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserCertificatesList<TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserCertificatesList<TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserCertificatesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Activate a user course by setting the 'has_access' field to True.
 */
export const userCourseActivateCreate = (
    userCourseActivateCreateBody: BodyType<UserCourseActivateCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/user-course-activate/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCourseActivateCreateBody, signal
    },
      options);
    }
  


export const getUserCourseActivateCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userCourseActivateCreate>>, TError,{data: BodyType<UserCourseActivateCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof userCourseActivateCreate>>, TError,{data: BodyType<UserCourseActivateCreateBody>}, TContext> => {
    
const mutationKey = ['userCourseActivateCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userCourseActivateCreate>>, {data: BodyType<UserCourseActivateCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  userCourseActivateCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserCourseActivateCreateMutationResult = NonNullable<Awaited<ReturnType<typeof userCourseActivateCreate>>>
    export type UserCourseActivateCreateMutationBody = BodyType<UserCourseActivateCreateBody>
    export type UserCourseActivateCreateMutationError = ErrorType<unknown>

    export const useUserCourseActivateCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userCourseActivateCreate>>, TError,{data: BodyType<UserCourseActivateCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userCourseActivateCreate>>,
        TError,
        {data: BodyType<UserCourseActivateCreateBody>},
        TContext
      > => {

      const mutationOptions = getUserCourseActivateCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∫—É—Ä—Å–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∫ –∫–æ—Ç–æ—Ä—ã–º —É –Ω–µ–≥–æ –µ—Å—Ç—å –¥–æ—Å—Ç—É–ø.
 */
export const userCoursesList = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserCoursesList200Item[]>(
      {url: `/user-courses/`, method: 'GET', signal
    },
      options);
    }
  

export const getUserCoursesListQueryKey = () => {
    return [`/user-courses/`] as const;
    }

    
export const getUserCoursesListQueryOptions = <TData = Awaited<ReturnType<typeof userCoursesList>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserCoursesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userCoursesList>>> = ({ signal }) => userCoursesList(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserCoursesListQueryResult = NonNullable<Awaited<ReturnType<typeof userCoursesList>>>
export type UserCoursesListQueryError = ErrorType<void>


export function useUserCoursesList<TData = Awaited<ReturnType<typeof userCoursesList>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userCoursesList>>,
          TError,
          Awaited<ReturnType<typeof userCoursesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserCoursesList<TData = Awaited<ReturnType<typeof userCoursesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userCoursesList>>,
          TError,
          Awaited<ReturnType<typeof userCoursesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserCoursesList<TData = Awaited<ReturnType<typeof userCoursesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserCoursesList<TData = Awaited<ReturnType<typeof userCoursesList>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserCoursesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –ø–æ –µ–≥–æ ID, –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–º—É –∫–∞–∫ query –ø–∞—Ä–∞–º–µ—Ç—Ä.
 */
export const userList = (
    params: UserListParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<User>(
      {url: `/user/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getUserListQueryKey = (params: UserListParams,) => {
    return [`/user/`, ...(params ? [params]: [])] as const;
    }

    
export const getUserListQueryOptions = <TData = Awaited<ReturnType<typeof userList>>, TError = ErrorType<unknown>>(params: UserListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userList>>> = ({ signal }) => userList(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserListQueryResult = NonNullable<Awaited<ReturnType<typeof userList>>>
export type UserListQueryError = ErrorType<unknown>


export function useUserList<TData = Awaited<ReturnType<typeof userList>>, TError = ErrorType<unknown>>(
 params: UserListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userList>>,
          TError,
          Awaited<ReturnType<typeof userList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserList<TData = Awaited<ReturnType<typeof userList>>, TError = ErrorType<unknown>>(
 params: UserListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userList>>,
          TError,
          Awaited<ReturnType<typeof userList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserList<TData = Awaited<ReturnType<typeof userList>>, TError = ErrorType<unknown>>(
 params: UserListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserList<TData = Awaited<ReturnType<typeof userList>>, TError = ErrorType<unknown>>(
 params: UserListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const verifyCodeCreate = (
    verifyCodeCreateBody: BodyType<VerifyCodeCreateBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/verify-code/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: verifyCodeCreateBody, signal
    },
      options);
    }
  


export const getVerifyCodeCreateMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyCodeCreate>>, TError,{data: BodyType<VerifyCodeCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof verifyCodeCreate>>, TError,{data: BodyType<VerifyCodeCreateBody>}, TContext> => {
    
const mutationKey = ['verifyCodeCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyCodeCreate>>, {data: BodyType<VerifyCodeCreateBody>}> = (props) => {
          const {data} = props ?? {};

          return  verifyCodeCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyCodeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof verifyCodeCreate>>>
    export type VerifyCodeCreateMutationBody = BodyType<VerifyCodeCreateBody>
    export type VerifyCodeCreateMutationError = ErrorType<void>

    export const useVerifyCodeCreate = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyCodeCreate>>, TError,{data: BodyType<VerifyCodeCreateBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyCodeCreate>>,
        TError,
        {data: BodyType<VerifyCodeCreateBody>},
        TContext
      > => {

      const mutationOptions = getVerifyCodeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
