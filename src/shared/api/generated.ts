/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * API –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
 * –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –¥–ª—è API
 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

export interface Course {
  readonly id?: number;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title_ru: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title_kz: string;
  /** @minLength 1 */
  description_ru: string;
  /** @minLength 1 */
  description_kz: string;
  price: string;
  is_published?: boolean;
}

export interface Lesson {
  readonly id?: number;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title_ru: string;
  /**
   * @minLength 1
   * @maxLength 255
   */
  title_kz: string;
  /** @minLength 1 */
  content_ru: string;
  /** @minLength 1 */
  content_kz: string;
  /** @nullable */
  readonly media_ru?: string | null;
  /** @nullable */
  readonly media_kz?: string | null;
  /**
   * @minimum 0
   * @maximum 9223372036854776000
   */
  order_num: number;
}

export type FinalTestQuestionsRu = { [key: string]: unknown };

export type FinalTestQuestionsKz = { [key: string]: unknown };

export interface FinalTest {
  readonly id?: number;
  questions_ru: FinalTestQuestionsRu;
  questions_kz: FinalTestQuestionsKz;
  readonly created_at?: string;
  course: number;
}

export type LessonTestQuestionsRu = { [key: string]: unknown };

export type LessonTestQuestionsKz = { [key: string]: unknown };

export interface LessonTest {
  readonly id?: number;
  questions_ru: LessonTestQuestionsRu;
  questions_kz: LessonTestQuestionsKz;
  readonly created_at?: string;
  lesson: number;
}

export interface Payment {
  readonly id?: number;
  amount: string;
  /**
   * @minLength 1
   * @maxLength 10
   */
  status?: string;
  readonly created_at?: string;
  user: number;
  course: number;
}

export interface Certificate {
  readonly id?: number;
  readonly issued_at?: string;
  user: number;
  course: number;
}

export interface UserCourse {
  readonly id?: number;
  has_access?: boolean;
  readonly enrolled_at?: string;
  user: number;
  course: number;
}

export type FinalTestBody = FinalTest;

export type LessonBody = Lesson;

export type CourseBody = Course;

export type LessonTestBody = LessonTest;

export type PaymentBody = Payment;

/**
 * –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞, –≥–¥–µ –∫–ª—é—á - ID –≤–æ–ø—Ä–æ—Å–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç
 */
export type FinalTestSubmitCreateBodyAnswers = { [key: string]: unknown };

export type FinalTestSubmitCreateBody = {
  /** Course id */
  course_id?: number;
  /** –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞, –≥–¥–µ –∫–ª—é—á - ID –≤–æ–ø—Ä–æ—Å–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç */
  answers: FinalTestSubmitCreateBodyAnswers;
  /** –Ø–∑—ã–∫, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –≤–æ–ø—Ä–æ—Å—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 'ru') */
  language?: string;
};

export type FinalTestSubmitCreate200 = {
  /** –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ */
  score?: number;
  /** –§–ª–∞–≥, —É–∫–∞–∑—ã–≤–∞—é—â–∏–π, –±—ã–ª –ª–∏ –≤—ã–¥–∞–Ω —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç */
  certificate_issued?: boolean;
};

/**
 * –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã, –≥–¥–µ –∫–ª—é—á - ID –≤–æ–ø—Ä–æ—Å–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç
 */
export type LessonTestSubmitCreateBodyAnswers = { [key: string]: unknown };

export type LessonTestSubmitCreateBody = {
  /** Lesson test id */
  lesson_test_id?: number;
  /** –û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã, –≥–¥–µ –∫–ª—é—á - ID –≤–æ–ø—Ä–æ—Å–∞, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ - –≤—ã–±—Ä–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç */
  answers: LessonTestSubmitCreateBodyAnswers;
  /** –Ø–∑—ã–∫, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –≤–æ–ø—Ä–æ—Å—ã (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 'ru') */
  language?: string;
};

export type LessonTestSubmitCreate200 = {
  /** –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤ */
  score?: number;
};

export type LoginCreateBody = {
  /** –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
  phone_number: string;
  /** –ü–∞—Ä–æ–ª—å */
  password: string;
};

export type LoginCreate200 = {
  /** Access-—Ç–æ–∫–µ–Ω */
  access?: string;
  /** Refresh-—Ç–æ–∫–µ–Ω */
  refresh?: string;
  /** –ü–æ–ª–Ω–æ–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  full_name?: string;
  /** –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
  phone_number?: string;
};

export type PurchaseCourseCreateBody = {
  /** ID –∫—É—Ä—Å–∞ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ */
  course_id: number;
};

export type PurchaseCourseCreate201 = {
  /** –°–æ–æ–±—â–µ–Ω–∏–µ –æ —Å—Ç–∞—Ç—É—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ */
  message?: string;
  /** ID —Å–æ–∑–¥–∞–Ω–Ω–æ–π –æ–ø–ª–∞—Ç—ã */
  payment_id?: number;
};

export type SendCodeCreateBody = {
  /** –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
  phone_number: string;
};

export type VerifyCodeCreateBody = {
  /** –ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ */
  phone_number: string;
  /** –ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–∑ SMS */
  code: string;
  /** –§–ò–û –∏–ª–∏ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  full_name?: string;
  /** –ü–∞—Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è */
  password: string;
  /** –î–æ–ª–∂–Ω–æ—Å—Ç—å */
  position?: string;
  /** –ú–µ—Å—Ç–æ —Ä–∞–±–æ—Ç—ã */
  workplace?: string;
  /** –ò–ò–ù */
  iin?: string;
};

export const availableCoursesList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Course[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/available-courses/`,options
    );
  }


export const getAvailableCoursesListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/available-courses/`] as const;
    }

    
export const getAvailableCoursesListQueryOptions = <TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAvailableCoursesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof availableCoursesList>>> = ({ signal }) => availableCoursesList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AvailableCoursesListQueryResult = NonNullable<Awaited<ReturnType<typeof availableCoursesList>>>
export type AvailableCoursesListQueryError = AxiosError<unknown>


export function useAvailableCoursesList<TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof availableCoursesList>>,
          TError,
          Awaited<ReturnType<typeof availableCoursesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAvailableCoursesList<TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof availableCoursesList>>,
          TError,
          Awaited<ReturnType<typeof availableCoursesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAvailableCoursesList<TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAvailableCoursesList<TData = Awaited<ReturnType<typeof availableCoursesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof availableCoursesList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAvailableCoursesListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const courseLessonsList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Lesson[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/course-lessons/`,options
    );
  }


export const getCourseLessonsListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/course-lessons/`] as const;
    }

    
export const getCourseLessonsListQueryOptions = <TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCourseLessonsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof courseLessonsList>>> = ({ signal }) => courseLessonsList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CourseLessonsListQueryResult = NonNullable<Awaited<ReturnType<typeof courseLessonsList>>>
export type CourseLessonsListQueryError = AxiosError<unknown>


export function useCourseLessonsList<TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseLessonsList>>,
          TError,
          Awaited<ReturnType<typeof courseLessonsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseLessonsList<TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseLessonsList>>,
          TError,
          Awaited<ReturnType<typeof courseLessonsList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseLessonsList<TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCourseLessonsList<TData = Awaited<ReturnType<typeof courseLessonsList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseLessonsList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCourseLessonsListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –∫—É—Ä—Å–æ–≤
 */
export const courseList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Course[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/course/`,options
    );
  }


export const getCourseListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/course/`] as const;
    }

    
export const getCourseListQueryOptions = <TData = Awaited<ReturnType<typeof courseList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCourseListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof courseList>>> = ({ signal }) => courseList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CourseListQueryResult = NonNullable<Awaited<ReturnType<typeof courseList>>>
export type CourseListQueryError = AxiosError<void>


export function useCourseList<TData = Awaited<ReturnType<typeof courseList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseList>>,
          TError,
          Awaited<ReturnType<typeof courseList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseList<TData = Awaited<ReturnType<typeof courseList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseList>>,
          TError,
          Awaited<ReturnType<typeof courseList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseList<TData = Awaited<ReturnType<typeof courseList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCourseList<TData = Awaited<ReturnType<typeof courseList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCourseListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –∫—É—Ä—Å–∞
 */
export const courseCreate = (
    courseBody: CourseBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Course>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/course/`,
      courseBody,options
    );
  }



export const getCourseCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseCreate>>, TError,{data: CourseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof courseCreate>>, TError,{data: CourseBody}, TContext> => {
    
const mutationKey = ['courseCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof courseCreate>>, {data: CourseBody}> = (props) => {
          const {data} = props ?? {};

          return  courseCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CourseCreateMutationResult = NonNullable<Awaited<ReturnType<typeof courseCreate>>>
    export type CourseCreateMutationBody = CourseBody
    export type CourseCreateMutationError = AxiosError<void>

    export const useCourseCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseCreate>>, TError,{data: CourseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof courseCreate>>,
        TError,
        {data: CourseBody},
        TContext
      > => {

      const mutationOptions = getCourseCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫—É—Ä—Å–µ –ø–æ ID
 */
export const courseRead = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Course>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/course/${id}/`,options
    );
  }


export const getCourseReadQueryKey = (id: number,) => {
    return [`http://192.168.8.4:8000/api/v1/course/${id}/`] as const;
    }

    
export const getCourseReadQueryOptions = <TData = Awaited<ReturnType<typeof courseRead>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCourseReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof courseRead>>> = ({ signal }) => courseRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CourseReadQueryResult = NonNullable<Awaited<ReturnType<typeof courseRead>>>
export type CourseReadQueryError = AxiosError<void>


export function useCourseRead<TData = Awaited<ReturnType<typeof courseRead>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseRead>>,
          TError,
          Awaited<ReturnType<typeof courseRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseRead<TData = Awaited<ReturnType<typeof courseRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof courseRead>>,
          TError,
          Awaited<ReturnType<typeof courseRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCourseRead<TData = Awaited<ReturnType<typeof courseRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useCourseRead<TData = Awaited<ReturnType<typeof courseRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof courseRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCourseReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∫—É—Ä—Å–µ
 */
export const courseUpdate = (
    id: number,
    courseBody: CourseBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Course>> => {
    
    
    return axios.put(
      `http://192.168.8.4:8000/api/v1/course/${id}/`,
      courseBody,options
    );
  }



export const getCourseUpdateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseUpdate>>, TError,{id: number;data: CourseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof courseUpdate>>, TError,{id: number;data: CourseBody}, TContext> => {
    
const mutationKey = ['courseUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof courseUpdate>>, {id: number;data: CourseBody}> = (props) => {
          const {id,data} = props ?? {};

          return  courseUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CourseUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof courseUpdate>>>
    export type CourseUpdateMutationBody = CourseBody
    export type CourseUpdateMutationError = AxiosError<void>

    export const useCourseUpdate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseUpdate>>, TError,{id: number;data: CourseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof courseUpdate>>,
        TError,
        {id: number;data: CourseBody},
        TContext
      > => {

      const mutationOptions = getCourseUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const coursePartialUpdate = (
    id: number,
    courseBody: CourseBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Course>> => {
    
    
    return axios.patch(
      `http://192.168.8.4:8000/api/v1/course/${id}/`,
      courseBody,options
    );
  }



export const getCoursePartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coursePartialUpdate>>, TError,{id: number;data: CourseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof coursePartialUpdate>>, TError,{id: number;data: CourseBody}, TContext> => {
    
const mutationKey = ['coursePartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coursePartialUpdate>>, {id: number;data: CourseBody}> = (props) => {
          const {id,data} = props ?? {};

          return  coursePartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoursePartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof coursePartialUpdate>>>
    export type CoursePartialUpdateMutationBody = CourseBody
    export type CoursePartialUpdateMutationError = AxiosError<unknown>

    export const useCoursePartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coursePartialUpdate>>, TError,{id: number;data: CourseBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof coursePartialUpdate>>,
        TError,
        {id: number;data: CourseBody},
        TContext
      > => {

      const mutationOptions = getCoursePartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ –∫—É—Ä—Å–∞ –ø–æ ID
 */
export const courseDelete = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `http://192.168.8.4:8000/api/v1/course/${id}/`,options
    );
  }



export const getCourseDeleteMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof courseDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['courseDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof courseDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  courseDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CourseDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof courseDelete>>>
    
    export type CourseDeleteMutationError = AxiosError<void>

    export const useCourseDelete = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof courseDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof courseDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getCourseDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ—Å—Ç –∫—É—Ä—Å–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏ —Å –≤–æ–∑–º–æ–∂–Ω—ã–º –≤—ã–¥–∞—á–µ–π —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞
 */
export const finalTestSubmitCreate = (
    finalTestSubmitCreateBody: FinalTestSubmitCreateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FinalTestSubmitCreate200>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/final-test-submit/`,
      finalTestSubmitCreateBody,options
    );
  }



export const getFinalTestSubmitCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestSubmitCreate>>, TError,{data: FinalTestSubmitCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestSubmitCreate>>, TError,{data: FinalTestSubmitCreateBody}, TContext> => {
    
const mutationKey = ['finalTestSubmitCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestSubmitCreate>>, {data: FinalTestSubmitCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  finalTestSubmitCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestSubmitCreateMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestSubmitCreate>>>
    export type FinalTestSubmitCreateMutationBody = FinalTestSubmitCreateBody
    export type FinalTestSubmitCreateMutationError = AxiosError<void>

    export const useFinalTestSubmitCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestSubmitCreate>>, TError,{data: FinalTestSubmitCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof finalTestSubmitCreate>>,
        TError,
        {data: FinalTestSubmitCreateBody},
        TContext
      > => {

      const mutationOptions = getFinalTestSubmitCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ñ–∏–Ω–∞–ª—å–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤
 */
export const finalTestList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FinalTest[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/final-test/`,options
    );
  }


export const getFinalTestListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/final-test/`] as const;
    }

    
export const getFinalTestListQueryOptions = <TData = Awaited<ReturnType<typeof finalTestList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFinalTestListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof finalTestList>>> = ({ signal }) => finalTestList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FinalTestListQueryResult = NonNullable<Awaited<ReturnType<typeof finalTestList>>>
export type FinalTestListQueryError = AxiosError<void>


export function useFinalTestList<TData = Awaited<ReturnType<typeof finalTestList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof finalTestList>>,
          TError,
          Awaited<ReturnType<typeof finalTestList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFinalTestList<TData = Awaited<ReturnType<typeof finalTestList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof finalTestList>>,
          TError,
          Awaited<ReturnType<typeof finalTestList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFinalTestList<TData = Awaited<ReturnType<typeof finalTestList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFinalTestList<TData = Awaited<ReturnType<typeof finalTestList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFinalTestListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞
 */
export const finalTestCreate = (
    finalTestBody: FinalTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FinalTest>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/final-test/`,
      finalTestBody,options
    );
  }



export const getFinalTestCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestCreate>>, TError,{data: FinalTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestCreate>>, TError,{data: FinalTestBody}, TContext> => {
    
const mutationKey = ['finalTestCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestCreate>>, {data: FinalTestBody}> = (props) => {
          const {data} = props ?? {};

          return  finalTestCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestCreate>>>
    export type FinalTestCreateMutationBody = FinalTestBody
    export type FinalTestCreateMutationError = AxiosError<void>

    export const useFinalTestCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestCreate>>, TError,{data: FinalTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof finalTestCreate>>,
        TError,
        {data: FinalTestBody},
        TContext
      > => {

      const mutationOptions = getFinalTestCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º —Ç–µ—Å—Ç–µ –ø–æ ID
 */
export const finalTestRead = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FinalTest>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/final-test/${id}/`,options
    );
  }


export const getFinalTestReadQueryKey = (id: number,) => {
    return [`http://192.168.8.4:8000/api/v1/final-test/${id}/`] as const;
    }

    
export const getFinalTestReadQueryOptions = <TData = Awaited<ReturnType<typeof finalTestRead>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFinalTestReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof finalTestRead>>> = ({ signal }) => finalTestRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FinalTestReadQueryResult = NonNullable<Awaited<ReturnType<typeof finalTestRead>>>
export type FinalTestReadQueryError = AxiosError<void>


export function useFinalTestRead<TData = Awaited<ReturnType<typeof finalTestRead>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof finalTestRead>>,
          TError,
          Awaited<ReturnType<typeof finalTestRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFinalTestRead<TData = Awaited<ReturnType<typeof finalTestRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof finalTestRead>>,
          TError,
          Awaited<ReturnType<typeof finalTestRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFinalTestRead<TData = Awaited<ReturnType<typeof finalTestRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFinalTestRead<TData = Awaited<ReturnType<typeof finalTestRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof finalTestRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFinalTestReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞
 */
export const finalTestUpdate = (
    id: number,
    finalTestBody: FinalTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FinalTest>> => {
    
    
    return axios.put(
      `http://192.168.8.4:8000/api/v1/final-test/${id}/`,
      finalTestBody,options
    );
  }



export const getFinalTestUpdateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestUpdate>>, TError,{id: number;data: FinalTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestUpdate>>, TError,{id: number;data: FinalTestBody}, TContext> => {
    
const mutationKey = ['finalTestUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestUpdate>>, {id: number;data: FinalTestBody}> = (props) => {
          const {id,data} = props ?? {};

          return  finalTestUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestUpdate>>>
    export type FinalTestUpdateMutationBody = FinalTestBody
    export type FinalTestUpdateMutationError = AxiosError<void>

    export const useFinalTestUpdate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestUpdate>>, TError,{id: number;data: FinalTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof finalTestUpdate>>,
        TError,
        {id: number;data: FinalTestBody},
        TContext
      > => {

      const mutationOptions = getFinalTestUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const finalTestPartialUpdate = (
    id: number,
    finalTestBody: FinalTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FinalTest>> => {
    
    
    return axios.patch(
      `http://192.168.8.4:8000/api/v1/final-test/${id}/`,
      finalTestBody,options
    );
  }



export const getFinalTestPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestPartialUpdate>>, TError,{id: number;data: FinalTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestPartialUpdate>>, TError,{id: number;data: FinalTestBody}, TContext> => {
    
const mutationKey = ['finalTestPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestPartialUpdate>>, {id: number;data: FinalTestBody}> = (props) => {
          const {id,data} = props ?? {};

          return  finalTestPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestPartialUpdate>>>
    export type FinalTestPartialUpdateMutationBody = FinalTestBody
    export type FinalTestPartialUpdateMutationError = AxiosError<unknown>

    export const useFinalTestPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestPartialUpdate>>, TError,{id: number;data: FinalTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof finalTestPartialUpdate>>,
        TError,
        {id: number;data: FinalTestBody},
        TContext
      > => {

      const mutationOptions = getFinalTestPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞ –ø–æ ID
 */
export const finalTestDelete = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `http://192.168.8.4:8000/api/v1/final-test/${id}/`,options
    );
  }



export const getFinalTestDeleteMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof finalTestDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['finalTestDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof finalTestDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  finalTestDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FinalTestDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof finalTestDelete>>>
    
    export type FinalTestDeleteMutationError = AxiosError<void>

    export const useFinalTestDelete = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof finalTestDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof finalTestDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getFinalTestDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ —Ç–µ—Å—Ç —É—Ä–æ–∫–∞ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –æ—Ü–µ–Ω–∫–∏
 */
export const lessonTestSubmitCreate = (
    lessonTestSubmitCreateBody: LessonTestSubmitCreateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LessonTestSubmitCreate200>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/lesson-test-submit/`,
      lessonTestSubmitCreateBody,options
    );
  }



export const getLessonTestSubmitCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestSubmitCreate>>, TError,{data: LessonTestSubmitCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestSubmitCreate>>, TError,{data: LessonTestSubmitCreateBody}, TContext> => {
    
const mutationKey = ['lessonTestSubmitCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestSubmitCreate>>, {data: LessonTestSubmitCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  lessonTestSubmitCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestSubmitCreateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestSubmitCreate>>>
    export type LessonTestSubmitCreateMutationBody = LessonTestSubmitCreateBody
    export type LessonTestSubmitCreateMutationError = AxiosError<void>

    export const useLessonTestSubmitCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestSubmitCreate>>, TError,{data: LessonTestSubmitCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestSubmitCreate>>,
        TError,
        {data: LessonTestSubmitCreateBody},
        TContext
      > => {

      const mutationOptions = getLessonTestSubmitCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ –∫ —É—Ä–æ–∫–∞–º
 */
export const lessonTestList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LessonTest[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/lesson-test/`,options
    );
  }


export const getLessonTestListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/lesson-test/`] as const;
    }

    
export const getLessonTestListQueryOptions = <TData = Awaited<ReturnType<typeof lessonTestList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLessonTestListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lessonTestList>>> = ({ signal }) => lessonTestList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LessonTestListQueryResult = NonNullable<Awaited<ReturnType<typeof lessonTestList>>>
export type LessonTestListQueryError = AxiosError<void>


export function useLessonTestList<TData = Awaited<ReturnType<typeof lessonTestList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonTestList>>,
          TError,
          Awaited<ReturnType<typeof lessonTestList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonTestList<TData = Awaited<ReturnType<typeof lessonTestList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonTestList>>,
          TError,
          Awaited<ReturnType<typeof lessonTestList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonTestList<TData = Awaited<ReturnType<typeof lessonTestList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLessonTestList<TData = Awaited<ReturnType<typeof lessonTestList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLessonTestListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç–µ—Å—Ç–∞
 */
export const lessonTestCreate = (
    lessonTestBody: LessonTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LessonTest>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/lesson-test/`,
      lessonTestBody,options
    );
  }



export const getLessonTestCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestCreate>>, TError,{data: LessonTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestCreate>>, TError,{data: LessonTestBody}, TContext> => {
    
const mutationKey = ['lessonTestCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestCreate>>, {data: LessonTestBody}> = (props) => {
          const {data} = props ?? {};

          return  lessonTestCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestCreateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestCreate>>>
    export type LessonTestCreateMutationBody = LessonTestBody
    export type LessonTestCreateMutationError = AxiosError<void>

    export const useLessonTestCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestCreate>>, TError,{data: LessonTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestCreate>>,
        TError,
        {data: LessonTestBody},
        TContext
      > => {

      const mutationOptions = getLessonTestCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ—Å—Ç–µ –ø–æ ID
 */
export const lessonTestRead = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LessonTest>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/lesson-test/${id}/`,options
    );
  }


export const getLessonTestReadQueryKey = (id: number,) => {
    return [`http://192.168.8.4:8000/api/v1/lesson-test/${id}/`] as const;
    }

    
export const getLessonTestReadQueryOptions = <TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLessonTestReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lessonTestRead>>> = ({ signal }) => lessonTestRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LessonTestReadQueryResult = NonNullable<Awaited<ReturnType<typeof lessonTestRead>>>
export type LessonTestReadQueryError = AxiosError<void>


export function useLessonTestRead<TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonTestRead>>,
          TError,
          Awaited<ReturnType<typeof lessonTestRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonTestRead<TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonTestRead>>,
          TError,
          Awaited<ReturnType<typeof lessonTestRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonTestRead<TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLessonTestRead<TData = Awaited<ReturnType<typeof lessonTestRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonTestRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLessonTestReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–∞
 */
export const lessonTestUpdate = (
    id: number,
    lessonTestBody: LessonTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LessonTest>> => {
    
    
    return axios.put(
      `http://192.168.8.4:8000/api/v1/lesson-test/${id}/`,
      lessonTestBody,options
    );
  }



export const getLessonTestUpdateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestUpdate>>, TError,{id: number;data: LessonTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestUpdate>>, TError,{id: number;data: LessonTestBody}, TContext> => {
    
const mutationKey = ['lessonTestUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestUpdate>>, {id: number;data: LessonTestBody}> = (props) => {
          const {id,data} = props ?? {};

          return  lessonTestUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestUpdate>>>
    export type LessonTestUpdateMutationBody = LessonTestBody
    export type LessonTestUpdateMutationError = AxiosError<void>

    export const useLessonTestUpdate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestUpdate>>, TError,{id: number;data: LessonTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestUpdate>>,
        TError,
        {id: number;data: LessonTestBody},
        TContext
      > => {

      const mutationOptions = getLessonTestUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const lessonTestPartialUpdate = (
    id: number,
    lessonTestBody: LessonTestBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LessonTest>> => {
    
    
    return axios.patch(
      `http://192.168.8.4:8000/api/v1/lesson-test/${id}/`,
      lessonTestBody,options
    );
  }



export const getLessonTestPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestPartialUpdate>>, TError,{id: number;data: LessonTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestPartialUpdate>>, TError,{id: number;data: LessonTestBody}, TContext> => {
    
const mutationKey = ['lessonTestPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestPartialUpdate>>, {id: number;data: LessonTestBody}> = (props) => {
          const {id,data} = props ?? {};

          return  lessonTestPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestPartialUpdate>>>
    export type LessonTestPartialUpdateMutationBody = LessonTestBody
    export type LessonTestPartialUpdateMutationError = AxiosError<unknown>

    export const useLessonTestPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestPartialUpdate>>, TError,{id: number;data: LessonTestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestPartialUpdate>>,
        TError,
        {id: number;data: LessonTestBody},
        TContext
      > => {

      const mutationOptions = getLessonTestPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–∞ –ø–æ ID
 */
export const lessonTestDelete = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `http://192.168.8.4:8000/api/v1/lesson-test/${id}/`,options
    );
  }



export const getLessonTestDeleteMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonTestDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['lessonTestDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonTestDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  lessonTestDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonTestDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof lessonTestDelete>>>
    
    export type LessonTestDeleteMutationError = AxiosError<void>

    export const useLessonTestDelete = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonTestDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonTestDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getLessonTestDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —É—Ä–æ–∫–æ–≤
 */
export const lessonList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Lesson[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/lesson/`,options
    );
  }


export const getLessonListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/lesson/`] as const;
    }

    
export const getLessonListQueryOptions = <TData = Awaited<ReturnType<typeof lessonList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLessonListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lessonList>>> = ({ signal }) => lessonList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LessonListQueryResult = NonNullable<Awaited<ReturnType<typeof lessonList>>>
export type LessonListQueryError = AxiosError<void>


export function useLessonList<TData = Awaited<ReturnType<typeof lessonList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonList>>,
          TError,
          Awaited<ReturnType<typeof lessonList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonList<TData = Awaited<ReturnType<typeof lessonList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonList>>,
          TError,
          Awaited<ReturnType<typeof lessonList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonList<TData = Awaited<ReturnType<typeof lessonList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLessonList<TData = Awaited<ReturnType<typeof lessonList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLessonListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —É—Ä–æ–∫–∞
 */
export const lessonCreate = (
    lessonBody: LessonBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Lesson>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/lesson/`,
      lessonBody,options
    );
  }



export const getLessonCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonCreate>>, TError,{data: LessonBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonCreate>>, TError,{data: LessonBody}, TContext> => {
    
const mutationKey = ['lessonCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonCreate>>, {data: LessonBody}> = (props) => {
          const {data} = props ?? {};

          return  lessonCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonCreateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonCreate>>>
    export type LessonCreateMutationBody = LessonBody
    export type LessonCreateMutationError = AxiosError<void>

    export const useLessonCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonCreate>>, TError,{data: LessonBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonCreate>>,
        TError,
        {data: LessonBody},
        TContext
      > => {

      const mutationOptions = getLessonCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —É—Ä–æ–∫–µ –ø–æ ID
 */
export const lessonRead = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Lesson>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/lesson/${id}/`,options
    );
  }


export const getLessonReadQueryKey = (id: number,) => {
    return [`http://192.168.8.4:8000/api/v1/lesson/${id}/`] as const;
    }

    
export const getLessonReadQueryOptions = <TData = Awaited<ReturnType<typeof lessonRead>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getLessonReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof lessonRead>>> = ({ signal }) => lessonRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type LessonReadQueryResult = NonNullable<Awaited<ReturnType<typeof lessonRead>>>
export type LessonReadQueryError = AxiosError<void>


export function useLessonRead<TData = Awaited<ReturnType<typeof lessonRead>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonRead>>,
          TError,
          Awaited<ReturnType<typeof lessonRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonRead<TData = Awaited<ReturnType<typeof lessonRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof lessonRead>>,
          TError,
          Awaited<ReturnType<typeof lessonRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useLessonRead<TData = Awaited<ReturnType<typeof lessonRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useLessonRead<TData = Awaited<ReturnType<typeof lessonRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof lessonRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getLessonReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —É—Ä–æ–∫–µ
 */
export const lessonUpdate = (
    id: number,
    lessonBody: LessonBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Lesson>> => {
    
    
    return axios.put(
      `http://192.168.8.4:8000/api/v1/lesson/${id}/`,
      lessonBody,options
    );
  }



export const getLessonUpdateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonUpdate>>, TError,{id: number;data: LessonBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonUpdate>>, TError,{id: number;data: LessonBody}, TContext> => {
    
const mutationKey = ['lessonUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonUpdate>>, {id: number;data: LessonBody}> = (props) => {
          const {id,data} = props ?? {};

          return  lessonUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonUpdate>>>
    export type LessonUpdateMutationBody = LessonBody
    export type LessonUpdateMutationError = AxiosError<void>

    export const useLessonUpdate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonUpdate>>, TError,{id: number;data: LessonBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonUpdate>>,
        TError,
        {id: number;data: LessonBody},
        TContext
      > => {

      const mutationOptions = getLessonUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const lessonPartialUpdate = (
    id: number,
    lessonBody: LessonBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Lesson>> => {
    
    
    return axios.patch(
      `http://192.168.8.4:8000/api/v1/lesson/${id}/`,
      lessonBody,options
    );
  }



export const getLessonPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonPartialUpdate>>, TError,{id: number;data: LessonBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonPartialUpdate>>, TError,{id: number;data: LessonBody}, TContext> => {
    
const mutationKey = ['lessonPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonPartialUpdate>>, {id: number;data: LessonBody}> = (props) => {
          const {id,data} = props ?? {};

          return  lessonPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof lessonPartialUpdate>>>
    export type LessonPartialUpdateMutationBody = LessonBody
    export type LessonPartialUpdateMutationError = AxiosError<unknown>

    export const useLessonPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonPartialUpdate>>, TError,{id: number;data: LessonBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonPartialUpdate>>,
        TError,
        {id: number;data: LessonBody},
        TContext
      > => {

      const mutationOptions = getLessonPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ —É—Ä–æ–∫–∞ –ø–æ ID
 */
export const lessonDelete = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `http://192.168.8.4:8000/api/v1/lesson/${id}/`,options
    );
  }



export const getLessonDeleteMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof lessonDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['lessonDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof lessonDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  lessonDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LessonDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof lessonDelete>>>
    
    export type LessonDeleteMutationError = AxiosError<void>

    export const useLessonDelete = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof lessonDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof lessonDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getLessonDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ –Ω–æ–º–µ—Ä—É —Ç–µ–ª–µ—Ñ–æ–Ω–∞ –∏ –ø–∞—Ä–æ–ª—é
 */
export const loginCreate = (
    loginCreateBody: LoginCreateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LoginCreate200>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/login/`,
      loginCreateBody,options
    );
  }



export const getLoginCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginCreate>>, TError,{data: LoginCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof loginCreate>>, TError,{data: LoginCreateBody}, TContext> => {
    
const mutationKey = ['loginCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginCreate>>, {data: LoginCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  loginCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginCreateMutationResult = NonNullable<Awaited<ReturnType<typeof loginCreate>>>
    export type LoginCreateMutationBody = LoginCreateBody
    export type LoginCreateMutationError = AxiosError<void>

    export const useLoginCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginCreate>>, TError,{data: LoginCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof loginCreate>>,
        TError,
        {data: LoginCreateBody},
        TContext
      > => {

      const mutationOptions = getLoginCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –ø–ª–∞—Ç–µ–∂–µ–π
 */
export const paymentList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Payment[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/payment/`,options
    );
  }


export const getPaymentListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/payment/`] as const;
    }

    
export const getPaymentListQueryOptions = <TData = Awaited<ReturnType<typeof paymentList>>, TError = AxiosError<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentList>>> = ({ signal }) => paymentList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentListQueryResult = NonNullable<Awaited<ReturnType<typeof paymentList>>>
export type PaymentListQueryError = AxiosError<void>


export function usePaymentList<TData = Awaited<ReturnType<typeof paymentList>>, TError = AxiosError<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentList>>,
          TError,
          Awaited<ReturnType<typeof paymentList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentList<TData = Awaited<ReturnType<typeof paymentList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentList>>,
          TError,
          Awaited<ReturnType<typeof paymentList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentList<TData = Awaited<ReturnType<typeof paymentList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePaymentList<TData = Awaited<ReturnType<typeof paymentList>>, TError = AxiosError<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞
 */
export const paymentCreate = (
    paymentBody: PaymentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Payment>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/payment/`,
      paymentBody,options
    );
  }



export const getPaymentCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentCreate>>, TError,{data: PaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentCreate>>, TError,{data: PaymentBody}, TContext> => {
    
const mutationKey = ['paymentCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentCreate>>, {data: PaymentBody}> = (props) => {
          const {data} = props ?? {};

          return  paymentCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentCreateMutationResult = NonNullable<Awaited<ReturnType<typeof paymentCreate>>>
    export type PaymentCreateMutationBody = PaymentBody
    export type PaymentCreateMutationError = AxiosError<void>

    export const usePaymentCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentCreate>>, TError,{data: PaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof paymentCreate>>,
        TError,
        {data: PaymentBody},
        TContext
      > => {

      const mutationOptions = getPaymentCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø–ª–∞—Ç–µ–∂–µ –ø–æ ID
 */
export const paymentRead = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Payment>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/payment/${id}/`,options
    );
  }


export const getPaymentReadQueryKey = (id: number,) => {
    return [`http://192.168.8.4:8000/api/v1/payment/${id}/`] as const;
    }

    
export const getPaymentReadQueryOptions = <TData = Awaited<ReturnType<typeof paymentRead>>, TError = AxiosError<void>>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentRead>>> = ({ signal }) => paymentRead(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentReadQueryResult = NonNullable<Awaited<ReturnType<typeof paymentRead>>>
export type PaymentReadQueryError = AxiosError<void>


export function usePaymentRead<TData = Awaited<ReturnType<typeof paymentRead>>, TError = AxiosError<void>>(
 id: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentRead>>,
          TError,
          Awaited<ReturnType<typeof paymentRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentRead<TData = Awaited<ReturnType<typeof paymentRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentRead>>,
          TError,
          Awaited<ReturnType<typeof paymentRead>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentRead<TData = Awaited<ReturnType<typeof paymentRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function usePaymentRead<TData = Awaited<ReturnType<typeof paymentRead>>, TError = AxiosError<void>>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentRead>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentReadQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞
 */
export const paymentUpdate = (
    id: number,
    paymentBody: PaymentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Payment>> => {
    
    
    return axios.put(
      `http://192.168.8.4:8000/api/v1/payment/${id}/`,
      paymentBody,options
    );
  }



export const getPaymentUpdateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentUpdate>>, TError,{id: number;data: PaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentUpdate>>, TError,{id: number;data: PaymentBody}, TContext> => {
    
const mutationKey = ['paymentUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentUpdate>>, {id: number;data: PaymentBody}> = (props) => {
          const {id,data} = props ?? {};

          return  paymentUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof paymentUpdate>>>
    export type PaymentUpdateMutationBody = PaymentBody
    export type PaymentUpdateMutationError = AxiosError<void>

    export const usePaymentUpdate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentUpdate>>, TError,{id: number;data: PaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof paymentUpdate>>,
        TError,
        {id: number;data: PaymentBody},
        TContext
      > => {

      const mutationOptions = getPaymentUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const paymentPartialUpdate = (
    id: number,
    paymentBody: PaymentBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Payment>> => {
    
    
    return axios.patch(
      `http://192.168.8.4:8000/api/v1/payment/${id}/`,
      paymentBody,options
    );
  }



export const getPaymentPartialUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentPartialUpdate>>, TError,{id: number;data: PaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentPartialUpdate>>, TError,{id: number;data: PaymentBody}, TContext> => {
    
const mutationKey = ['paymentPartialUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentPartialUpdate>>, {id: number;data: PaymentBody}> = (props) => {
          const {id,data} = props ?? {};

          return  paymentPartialUpdate(id,data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentPartialUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof paymentPartialUpdate>>>
    export type PaymentPartialUpdateMutationBody = PaymentBody
    export type PaymentPartialUpdateMutationError = AxiosError<unknown>

    export const usePaymentPartialUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentPartialUpdate>>, TError,{id: number;data: PaymentBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof paymentPartialUpdate>>,
        TError,
        {id: number;data: PaymentBody},
        TContext
      > => {

      const mutationOptions = getPaymentPartialUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –£–¥–∞–ª–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ –ø–æ ID
 */
export const paymentDelete = (
    id: number, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.delete(
      `http://192.168.8.4:8000/api/v1/payment/${id}/`,options
    );
  }



export const getPaymentDeleteMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof paymentDelete>>, TError,{id: number}, TContext> => {
    
const mutationKey = ['paymentDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentDelete>>, {id: number}> = (props) => {
          const {id} = props ?? {};

          return  paymentDelete(id,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof paymentDelete>>>
    
    export type PaymentDeleteMutationError = AxiosError<void>

    export const usePaymentDelete = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentDelete>>, TError,{id: number}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof paymentDelete>>,
        TError,
        {id: number},
        TContext
      > => {

      const mutationOptions = getPaymentDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –æ–ø–ª–∞—Ç—ã –∑–∞ –∫—É—Ä—Å.
 */
export const purchaseCourseCreate = (
    purchaseCourseCreateBody: PurchaseCourseCreateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PurchaseCourseCreate201>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/purchase-course/`,
      purchaseCourseCreateBody,options
    );
  }



export const getPurchaseCourseCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchaseCourseCreate>>, TError,{data: PurchaseCourseCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof purchaseCourseCreate>>, TError,{data: PurchaseCourseCreateBody}, TContext> => {
    
const mutationKey = ['purchaseCourseCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof purchaseCourseCreate>>, {data: PurchaseCourseCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  purchaseCourseCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PurchaseCourseCreateMutationResult = NonNullable<Awaited<ReturnType<typeof purchaseCourseCreate>>>
    export type PurchaseCourseCreateMutationBody = PurchaseCourseCreateBody
    export type PurchaseCourseCreateMutationError = AxiosError<void>

    export const usePurchaseCourseCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof purchaseCourseCreate>>, TError,{data: PurchaseCourseCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof purchaseCourseCreate>>,
        TError,
        {data: PurchaseCourseCreateBody},
        TContext
      > => {

      const mutationOptions = getPurchaseCourseCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ –∫–æ–¥–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–∞ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞
 */
export const sendCodeCreate = (
    sendCodeCreateBody: SendCodeCreateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/send-code/`,
      sendCodeCreateBody,options
    );
  }



export const getSendCodeCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendCodeCreate>>, TError,{data: SendCodeCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof sendCodeCreate>>, TError,{data: SendCodeCreateBody}, TContext> => {
    
const mutationKey = ['sendCodeCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendCodeCreate>>, {data: SendCodeCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  sendCodeCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SendCodeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof sendCodeCreate>>>
    export type SendCodeCreateMutationBody = SendCodeCreateBody
    export type SendCodeCreateMutationError = AxiosError<void>

    export const useSendCodeCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendCodeCreate>>, TError,{data: SendCodeCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof sendCodeCreate>>,
        TError,
        {data: SendCodeCreateBody},
        TContext
      > => {

      const mutationOptions = getSendCodeCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const userCertificatesList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<Certificate[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/user-certificates/`,options
    );
  }


export const getUserCertificatesListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/user-certificates/`] as const;
    }

    
export const getUserCertificatesListQueryOptions = <TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserCertificatesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userCertificatesList>>> = ({ signal }) => userCertificatesList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserCertificatesListQueryResult = NonNullable<Awaited<ReturnType<typeof userCertificatesList>>>
export type UserCertificatesListQueryError = AxiosError<unknown>


export function useUserCertificatesList<TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userCertificatesList>>,
          TError,
          Awaited<ReturnType<typeof userCertificatesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserCertificatesList<TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userCertificatesList>>,
          TError,
          Awaited<ReturnType<typeof userCertificatesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserCertificatesList<TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserCertificatesList<TData = Awaited<ReturnType<typeof userCertificatesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCertificatesList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserCertificatesListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const userCoursesList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserCourse[]>> => {
    
    
    return axios.get(
      `http://192.168.8.4:8000/api/v1/user-courses/`,options
    );
  }


export const getUserCoursesListQueryKey = () => {
    return [`http://192.168.8.4:8000/api/v1/user-courses/`] as const;
    }

    
export const getUserCoursesListQueryOptions = <TData = Awaited<ReturnType<typeof userCoursesList>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserCoursesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userCoursesList>>> = ({ signal }) => userCoursesList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserCoursesListQueryResult = NonNullable<Awaited<ReturnType<typeof userCoursesList>>>
export type UserCoursesListQueryError = AxiosError<unknown>


export function useUserCoursesList<TData = Awaited<ReturnType<typeof userCoursesList>>, TError = AxiosError<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userCoursesList>>,
          TError,
          Awaited<ReturnType<typeof userCoursesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserCoursesList<TData = Awaited<ReturnType<typeof userCoursesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userCoursesList>>,
          TError,
          Awaited<ReturnType<typeof userCoursesList>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserCoursesList<TData = Awaited<ReturnType<typeof userCoursesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserCoursesList<TData = Awaited<ReturnType<typeof userCoursesList>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userCoursesList>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserCoursesListQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–¥–∞ –∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
export const verifyCodeCreate = (
    verifyCodeCreateBody: VerifyCodeCreateBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    
    return axios.post(
      `http://192.168.8.4:8000/api/v1/verify-code/`,
      verifyCodeCreateBody,options
    );
  }



export const getVerifyCodeCreateMutationOptions = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyCodeCreate>>, TError,{data: VerifyCodeCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof verifyCodeCreate>>, TError,{data: VerifyCodeCreateBody}, TContext> => {
    
const mutationKey = ['verifyCodeCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyCodeCreate>>, {data: VerifyCodeCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  verifyCodeCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyCodeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof verifyCodeCreate>>>
    export type VerifyCodeCreateMutationBody = VerifyCodeCreateBody
    export type VerifyCodeCreateMutationError = AxiosError<void>

    export const useVerifyCodeCreate = <TError = AxiosError<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyCodeCreate>>, TError,{data: VerifyCodeCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof verifyCodeCreate>>,
        TError,
        {data: VerifyCodeCreateBody},
        TContext
      > => {

      const mutationOptions = getVerifyCodeCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
